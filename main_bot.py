import asyncio
import os
from typing import Any

from aiogram import Bot, Dispatcher, types
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.filters.command import Command
from aiogram.types import FSInputFile

from get_statistics import get_statistics

from keyboards import control_kb

import pandas as pd

from sqlalchemy import create_engine
from sqlalchemy import text as sql_text


# –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ–µ–¥–∏–Ω–∏—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º
engine = create_engine(os.getenv("DB_POSTGRESQL"))

TOKEN: str = os.getenv("BOT_TOKEN", "")

dp = Dispatcher()

enter_crys: str = "–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–∏—Å—Ç–∞–ª–æ–≤"


class UserData:
    def __init__(self) -> None:
        self._dict: dict[int, dict[str, str]] = dict()
        return

    @property
    def data(self) -> dict[int, dict[str, str]]:
        return self._dict

    def update(self, user_id: int, data: dict[str, str]) -> None:
        if user_id not in self._dict:
            self._dict.update({user_id: {}})
        self._dict[user_id].update(data)
        return

    def delete(self, user_id: int) -> None:
        if user_id in self._dict:
            self._dict.pop(user_id)
        return


async def sql(
    sql_text_request: str, params: dict[str, Any] | None = None
) -> bool:
    try:
        # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SQL - –∑–∞–ø—Ä–æ—Å–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        with engine.connect() as connection:
            connection.execute(sql_text(sql_text_request), parameters=params)
            connection.commit()
        return True
    except Exception as err:
        # logging.error(err)
        print(err)
        return False


@dp.message(CommandStart())
async def cmd_start(message: types.Message) -> None:
    if message.from_user is not None:
        user_id: int = int(message.from_user.id)
        df = pd.read_sql(
            "SELECT count(*) FROM users WHERE user_id = %(user_id)s;",
            params={"user_id": user_id},
            con=engine,
        )
        if df.iloc[0, 0] == 0:
            await sql(
                sql_text_request="""
                INSERT INTO users (
                        user_id,
                        first_name,
                        last_name,
                        username,
                        language_code
                ) VALUES(
                        :user_id,
                        :first_name,
                        :last_name,
                        :username,
                        :language_code
                );
                   """,
                params={
                    "user_id": user_id,
                    "first_name": message.from_user.first_name,
                    "last_name": message.from_user.last_name,
                    "username": message.from_user.username,
                    "language_code": message.from_user.language_code,
                },
            )
            await sql(
                sql_text_request="INSERT INTO raid (user_id) \
                VALUES(:user_id);",
                params={
                    "user_id": message.from_user.id,
                },
            )
        await message.answer(enter_crys, reply_markup=control_kb)
        u_data.delete(user_id)
    return


@dp.message(Command("cancel"))
async def cmd_cancel(message: types.Message) -> None:
    if message.from_user is not None:
        u_data.delete(int(message.from_user.id))
    return


@dp.message(Command("get_stat"))
async def get_stat(message: types.Message) -> None:
    await message.answer(text="–°–æ–±–∏—Ä–∞—é –¥–∞–Ω–Ω—ã–µ...")
    if message.from_user is not None:
        path_img = get_statistics(int(message.from_user.id))
        photo = FSInputFile(path_img)
        await message.answer_photo(photo=photo, caption="–í–æ—Ç —Ç–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
    return


async def write_in_db(message: types.Message) -> None:
    if message.from_user is not None:
        user_id: int = int(message.from_user.id)
    if user_id in u_data.data:
        if "num" in u_data.data[user_id] and "choice" in u_data.data[user_id]:
            num: int = 0
            old_num: int = 0
            pristine_mif_num: int = 0
            df: pd.DataFrame = pd.read_sql(
                "SELECT * FROM raid WHERE user_id = %(user_id)s;",
                params={"user_id": user_id},
                con=engine,
            )
            for idx, row in df.iterrows():
                old_num = int(row[u_data.data[user_id]["choice"]])
                pristine_mif_num = int(row["pristine_mif"])
            if u_data.data[user_id]["num"] != "del":
                num = int(u_data.data[user_id]["num"]) + old_num
                if u_data.data[user_id]["choice"] == "sacred":
                    await message.answer(
                        f"–î–æ–±–∞–≤–∏–ª. –û—Å—Ç–∞–ª–æ—Å—å –ø—Ä–∏–º–µ—Ä–Ω–æ {56 - num} \
{enter_crys}",
                        reply_markup=control_kb,
                    )
                elif u_data.data[user_id]["choice"] == "pristine":
                    num_mif = (
                        int(u_data.data[user_id]["num"]) + pristine_mif_num
                    )
                    await message.answer(
                        f"–î–æ–±–∞–≤–∏–ª. –û—Å—Ç–∞–ª–æ—Å—å –ø—Ä–∏–º–µ—Ä–Ω–æ –¥–æ –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ \
{180 - num} –∏ –¥–æ –º–∏—Ñ–∏—á–µ—Å–∫–æ–≥–æ {210 - num_mif}\n{enter_crys}",
                        reply_markup=control_kb,
                    )
                    await sql(
                        sql_text_request="""
                        UPDATE raid SET pristine_mif = :num_mif
                        WHERE user_id = :user_id;
                        """,
                        params={"num_mif": num_mif, "user_id": user_id},
                    )
                else:
                    await message.answer(
                        f"–î–æ–±–∞–≤–∏–ª. –û—Å—Ç–∞–ª–æ—Å—å –ø—Ä–∏–º–µ—Ä–Ω–æ {226 - num} {enter_crys}",
                        reply_markup=control_kb,
                    )
            else:
                await sql(
                    sql_text_request="""
                    INSERT INTO arrival_legend (
                            user_id,
                            quantity,
                            crystal
                    ) VALUES(
                            :user_id,
                            :quantity,
                            :crystal
                    );
                            """,
                    params={
                        "user_id": user_id,
                        "quantity": old_num + 1,
                        "crystal": u_data.data[user_id]["choice"],
                    },
                )
                await message.answer(
                    f"–°—á–µ—Ç—á–∏–∫ –æ–±–Ω—É–ª–∏–ª. {enter_crys}...",
                    reply_markup=control_kb,
                )

            await sql(
                sql_text_request=f"""
                UPDATE raid SET {u_data.data[user_id]['choice']} = '{num}'
                WHERE user_id = '{user_id}';
                """
            )
            u_data.delete(user_id)
    return


@dp.message()
async def content_type_text(message: types.Message) -> None:
    chois_type_crystal: str = """
–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫—Ä–∏—Å—Ç–∞–ª–æ–≤
üü¶ –î—Ä–µ–≤–Ω–∏–π
üü™ –¢–µ–º–Ω—ã–π
üüß –°–∞–∫—Ä–∞–ª—å–Ω—ã–π
üü• –ü–µ—Ä–≤–æ–∑–¥–∞–Ω–Ω—ã–π
üëá
"""
    if message.text is not None:
        msg: str = str(message.text)
        if message.from_user is not None:
            user_id: int = int(message.from_user.id)
            if msg.isnumeric() and msg.isdecimal():
                if user_id not in u_data.data:
                    u_data.update(user_id, {"num": msg})
                    await message.answer(
                        chois_type_crystal,
                        reply_markup=control_kb,
                    )
                else:
                    if "choice" not in u_data.data[user_id]:
                        await message.answer(
                            chois_type_crystal,
                            reply_markup=control_kb,
                        )
                    u_data.update(user_id, {"num": msg})
                    await write_in_db(message)
            elif "—Å–±—Ä–æ—Å–∏—Ç—å —Å—á—ë—Ç—á–∏–∫(–ª–µ–≥–∞ –ø—Ä–∏—à–ª–∞)" == msg.lower():
                await message.answer(
                    """
–ü–æ–∑–¥—Ä–∞–≤–ª—è—é!ü•≥ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫—Ä–∏—Å—Ç–∞–ª–æ–≤ –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –Ω—É–∂–Ω–æ —Å–±—Ä–æ—Å–∏—Ç—å —Å—á–µ—Ç—á–∏–∫.
üü¶üü™üüßüü• üëá
""",
                    reply_markup=control_kb,
                )
                u_data.update(user_id, {"num": "del"})
            elif "—Å–±—Ä–æ—Å–∏—Ç—å —Å—á—ë—Ç—á–∏–∫(–º–∏—Ñ–∏–∫ –ø—Ä–∏—à–µ–ª)" == msg.lower():
                await message.answer(
                    "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é!ü§©ü•≥", reply_markup=control_kb
                )
                await sql(
                    sql_text_request="""
                    UPDATE raid SET pristine_mif = '0'
                    WHERE user_id = :user_id;
                    """,
                    params={"user_id": user_id},
                )
            elif "–ø–æ–∫–∞–∑–∞—Ç—å –º–æ—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É" == msg.lower():
                await get_stat(message)
            elif "–ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π" == msg.lower():
                photo = FSInputFile("./event.jpg")
                await message.answer_photo(photo=photo)
            elif "–ø–æ–∫–∞–∑–∞—Ç—å –º–µ—Ç–∫–æ—Å—Ç—å –∏ —Å–∫–æ—Ä–æ—Å—Ç—å –∫–±" == msg.lower():
                photo = FSInputFile("./clan_boss_speed_and_accuracy.jpg")
                await message.answer_photo(photo=photo)
            elif "–ø–æ–∫–∞–∑–∞—Ç—å c–∫–æ–ª—å–∫–æ –∫—Ä–∞—Å–∫–∏ –Ω–∞–¥–æ" == msg.lower():
                photo = FSInputFile("./potion.jpg")
                await message.answer_photo(photo=photo)
            elif "–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ" == msg.lower():
                df = pd.read_sql(
                    "SELECT * FROM raid WHERE user_id = %(user_id)s;",
                    params={"user_id": user_id},
                    con=engine,
                )
                for idx, row in df.iterrows():
                    ancient: int = int(row["ancient"])
                    dark: int = int(row["dark"])
                    sacred: int = int(row["sacred"])
                    pristine: int = int(row["pristine"])
                    pristine_mif: int = int(row["pristine_mif"])
                    break
                await message.answer(
                    f"""üü¶ –î—Ä–µ–≤–Ω–∏–π - –≤—Å–µ–≥–æ {ancient}, \
–æ—Å—Ç–∞–ª–æ—Å—å {226 - ancient}\n\
üü™ –¢–µ–º–Ω—ã–π - –≤—Å–µ–≥–æ {dark}, –æ—Å—Ç–∞–ª–æ—Å—å {226 - dark}\
\nüüß –°–∞–∫—Ä–∞–ª—å–Ω—ã–π - –≤—Å–µ–≥–æ {sacred}, \
–æ—Å—Ç–∞–ª–æ—Å—å {56 - sacred}\nüü• –ü–µ—Ä–≤–æ–∑–¥–∞–Ω–Ω—ã–π:\n\
- –¥–ª—è –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –≥–µ—Ä–æ—è –≤—Å–µ–≥–æ {pristine}, \
–æ—Å—Ç–∞–ª–æ—Å—å {180 - pristine}\n\
- –¥–ª—è –º–∏—Ñ–∏—á–µ—Å–∫–æ–≥–æ –≥–µ—Ä–æ—è –≤—Å–µ–≥–æ {pristine_mif}, \
–æ—Å—Ç–∞–ª–æ—Å—å {210 - pristine_mif}"""
                )
            elif (
                "–¥—Ä–µ–≤–Ω" in msg.lower()
                or "—Ç–µ–º–Ω" in msg.lower()
                or "—Å–∞–∫—Ä–∞–ª" in msg.lower()
                or "–ø–µ—Ä–≤–æ–∑–¥" in msg.lower()
                or "—Å–∏–Ω–∏–π" in msg.lower()
                or "—Ñ–∏–æ–ª" in msg.lower()
                or "–æ—Ä–∞–Ω–∂" in msg.lower()
                or "–∫—Ä–∞—Å–Ω—ã–π" in msg.lower()
                or "–º–∏—Ñ–∏" in msg.lower()
            ):
                choice: str = "0"
                if "–¥—Ä–µ–≤–Ω" in msg.lower() or "—Å–∏–Ω–∏–π" in msg.lower():
                    choice = "ancient"
                elif "—Ç–µ–º–Ω" in msg.lower() or "—Ñ–∏–æ–ª" in msg.lower():
                    choice = "dark"
                elif "—Å–∞–∫—Ä–∞–ª" in msg.lower() or "–æ—Ä–∞–Ω–∂" in msg.lower():
                    choice = "sacred"
                elif (
                    "–ø–µ—Ä–≤–æ–∑–¥" in msg.lower()
                    or "–∫—Ä–∞—Å–Ω—ã–π" in msg.lower()
                    or "–º–∏—Ñ–∏" in msg.lower()
                ):
                    choice = "pristine"
                if choice != "0":
                    if user_id not in u_data.data:
                        u_data.update(user_id, {"choice": choice})
                        await message.answer(enter_crys)
                    else:
                        if "num" not in u_data.data[user_id]:
                            await message.answer(enter_crys)
                        u_data.update(user_id, {"choice": choice})
                        await write_in_db(message)
    return


async def set_default_commands(bot: Bot) -> None:
    await bot.set_my_commands(
        [
            types.BotCommand(command="start", description="–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"),
            types.BotCommand(
                command="cancel",
                description="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏ –Ω–∞—á–∞—Ç—å –≤—Å–µ —Å –Ω–∞—á–∞–ª–∞",
            ),
        ]
    )
    return


# async def main() -> None:
#     await set_default_commands()
#     dp.register_message_handler(cmd_start, commands="start", state="*")
#     dp.register_message_handler(
#         cmd_cancel, Text(equals="–æ—Ç–º–µ–Ω–∞", ignore_case=True), state="*"
#     )
#     dp.register_message_handler(
#         content_type_text, content_types=types.ContentType.TEXT
#     )
#
#     await dp.skip_updates()
#     await dp.start_polling()
#     return


async def main() -> None:
    # Initialize Bot instance with a default parse mode which will be passed
    # to all API calls
    bot = Bot(TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    await set_default_commands(bot)
    # And the run events dispatching
    await dp.start_polling(bot)


if __name__ == "__main__":
    u_data = UserData()
    asyncio.run(main())
